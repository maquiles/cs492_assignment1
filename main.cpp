/*
** Matthew Aquiles, Thomas Falsone
** 3/5/2018
** 
** Compiled with C++ 2011
*/

#include <iostream>
#include <stdio.h>
#include <pthread.h> 
#include <sys/time.h>
#include <list>
#include <random>
#include <sstream>
#include <fstream>
#include <unistd.h>
#include <stdlib.h>
#include <time.h>
#include <climits>

using namespace std;

//Product to be added to the queue
struct Product {
    int product_id;             //product id
    clock_t ts;                 //timestamp for when product is produced
    int life;                   //randomly generated "life" of product
    clock_t end_ts;             //timestamp for when product is consumed
    uint64_t consumption_time;  //tally of time being consumed, used to subtract from turn-around to get wait time

    Product(int id, unsigned int seed, uint64_t t, int l) : product_id(id), ts(t), life(l), consumption_time(0) {}
    ~Product(){}
};

//queue class using c++ standard linked list
class Queue {
    size_t size; //max size
    list<Product*> queue;
public:
    Queue(size_t s) : size(s) {}
    Queue() {}
    ~Queue() {}

    Product* pop() {
        Product* out = nullptr;
        if(!queue.empty()){
            out = queue.front();
            queue.pop_front();
        }
        return out;
    }

    void push(Product *p) {
        if(queue.size() != size || size == 0){
            queue.push_back(p);
        }
    } 

    bool empty(){
        return queue.empty();
    }

    bool full(){
        return (queue.size() == size && size != 0);
    }
};

int consumed = 0;           //number of products that have been comsumed
int id = 0;                 //ids of products, counts amount created
int seed;                   //seed for random numbers
int product_num;            //number of products to be generated
int quantum;                //quantum for round robin
Queue* q;                   

timeval tv;                 //calculated the time values for performace analysis
uint64_t min_t = INT_MAX;   //min turn around
uint64_t max_t = 0;         //max turn around
uint64_t av_t = 0;          //average time, holds the total weight time and is divided by product_num in main()
uint64_t min_w = INT_MAX;   //min wait time
uint64_t max_w = 0;         //max wait time
uint64_t av_w = 0;          //average wait time, holds the total weight time and is divided by product_num in main()
uint64_t curr_time;         //current time

pthread_mutex_t q_mutex;    //mutex to control which process is in the q is active
pthread_cond_t full;        //condition to prevent accessing full q
pthread_cond_t cond_empty;       //condition to prevent accessing empty q

//function to return the nth fibonacci number iteratively
void fn(int n){
    int a = 1;
    int b = 0;
    int c;
    while (n > 0){
        c = a;
        a = a+b;
        b=c;
        n--;
    }
}

timeval producer_start, producer_end;
timeval consumer_start, consumer_end;

//producer to create products to put into the q
void *producer(void* i){
    //int a = *((int *)i); //producer id
    while (true){
        pthread_mutex_lock(&q_mutex);

        //wait while the q is full
        while (id < product_num && q->full()){
            pthread_cond_wait(&full, &q_mutex);
        }

        if(id < product_num){
            //contsruct the product
            gettimeofday(&tv, nullptr);
            uint64_t t = tv.tv_sec*(uint64_t)1000000 + tv.tv_usec; //get the current timestamp

            // if this is the first item being produced, get timeval of first producer
            if (id == 0) { gettimeofday(&producer_start, NULL); }

            Product* p = new Product(id, seed, t, rand()%1024);
            id++;
            q->push(p);

            cout<< "Product "<< p->product_id<< " generated by producer \n";

            pthread_mutex_unlock(&q_mutex);
            pthread_cond_signal(&cond_empty);
        }

        if(id >= product_num){
            // last product, producers finish, get timeval
            gettimeofday(&producer_end, NULL);
            pthread_mutex_unlock(&q_mutex);
            pthread_cond_broadcast(&cond_empty); //broadcast to any consumers waiting to end
            break;
        }
        usleep(100000);
    }
    pthread_exit(0);
}

//round robin consumer function
void *consumer_RR(void* i){
    int a = *((int *) i);
    while (true){
        pthread_mutex_lock(&q_mutex);

        //wait while the q is empty
        while (consumed < product_num && q->empty()){
            pthread_cond_wait(&cond_empty, &q_mutex);
        }

        if(consumed < product_num){
            Product* p = q->pop();

            // if this is first product being consumed, start consumer throughput counter
            if (p->product_id == 0) { gettimeofday(&consumer_start, NULL); }

            if(p != nullptr){ 
                //handle the product if life longer than quantum
                if(p->life >= quantum){
                    p->life -= quantum; 

                    //get timestamp of start of consumption
                    gettimeofday(&tv, nullptr);
                    uint64_t start_cons = tv.tv_sec*(uint64_t)1000000 + tv.tv_usec;

                    //insert into the product based on the quantum
                    for(int i = 0; i<quantum; i++){
                        fn(10);
                    }

                    //get timestamp of end of this part of consumption
                    gettimeofday(&tv, nullptr);
                    uint64_t end_cons = tv.tv_sec*(uint64_t)1000000 + tv.tv_usec;
                    
                    //calculate time of this part of consumption and record in Product
                    p->consumption_time += end_cons - start_cons;

                    //insert to back of q for further consumption
                    q->push(p);
                }
                else { //handle the entire product
                    //get start time of consumption
                    gettimeofday(&tv, nullptr);
                    uint64_t start_cons = tv.tv_sec*(uint64_t)1000000 + tv.tv_usec;

                    for (int i = 0; i<p->life; i++){
                        fn(10);
                    }

                    //get end time of consumption
                    gettimeofday(&tv, nullptr);
                    uint64_t end_cons = tv.tv_sec*(uint64_t)1000000 + tv.tv_usec;

                    //calculate time of this part of consumption and record in Product
                    p->consumption_time += end_cons - start_cons;

                    //update end_time of product to calculate turn around time
                    p->end_ts = end_cons;

                    //calculate turn around time for product
                    uint64_t tat = p->end_ts - p->ts;

                    //check for min/max turn around time
                    if(tat > max_t){
                        max_t = tat;
                    }
                    if(tat < min_t){
                        min_t = tat;
                    }

                    //add to tally of turn around time
                    av_t += tat;

                    //calculate wait time for product
                    uint64_t wt = tat - p->consumption_time;

                    //check for min/max wait time
                    if(wt > max_w){
                        max_w = wt;
                    }
                    if(wt < min_w){
                        min_w = wt;
                    }

                    //add to tally of wait time for product
                    av_w += wt;

                    cout<< "Product "<< p->product_id<< " consumed by consumer \n";

                    consumed++;

                    // check to see if all products have been consumed, if so end consumer throughput
                    if (consumed == product_num) { gettimeofday(&consumer_end, NULL); }

                    delete p;
                }
            }

            //signal that the q is not full
            pthread_cond_signal(&full);
            pthread_mutex_unlock(&q_mutex);
            usleep(100000);
        }

        if(consumed >= product_num){
            pthread_mutex_unlock(&q_mutex);
            pthread_cond_broadcast(&full); //broadcast to any producers waiting to end
            break;
        }
    }
    pthread_exit(0);
}

//first come first serve consumer function
void *consumer_FCFS(void* i){
    int a = *((int *) i);
    while(true){
        //lock the q
        pthread_mutex_lock(&q_mutex);

        //wait while the q is empty
        while(consumed < product_num && q->empty()){
            pthread_cond_wait(&cond_empty, &q_mutex);
        }

        if(consumed++ < product_num){
            Product* p = q->pop();
            // start consumer throughput if first item
            if (p->product_id == 0) { gettimeofday(&consumer_start, NULL); }

            cout<< "Product "<< p->product_id<< " consumed by consumer "<< a<< "\n";

            //get current time to calculate wait time for product
            gettimeofday(&tv, nullptr);
            curr_time = tv.tv_sec*(uint64_t)1000000 + tv.tv_usec; //update the current time
            
            //calculate wait time and add to running tally of wait time
            av_w += curr_time - p->ts;

            //check for update in min/max wait times
            if(curr_time - p->ts > max_w){
                max_w = curr_time - p->ts;
            }
            if(curr_time - p->ts < min_w){
                min_w = curr_time - p->ts;
            }

            //consume the product
            if(p != nullptr){
                for (int i = 0; i<p->life; i++){
                    fn(10);
                }
            }

            //get current time to calculate turn around time
            gettimeofday(&tv, nullptr);
            curr_time = tv.tv_sec*(uint64_t)1000000 + tv.tv_usec;

            //calculate turn around time and add to running tally of turn around time
            av_t += curr_time - p->ts;

            //check for update in min/max turn around time
            if(curr_time - p->ts > max_t){
                max_t = curr_time - p->ts;
            }

            if(curr_time - p->ts < min_t){
                min_t = curr_time - p->ts;
            }

            // end consumer throughput if last product
            if (consumed == product_num) { gettimeofday(&consumer_end, NULL); }

            delete p;
            pthread_cond_signal(&full);
            pthread_mutex_unlock(&q_mutex);
            usleep(100000);
        }
        if(consumed >= product_num){
            pthread_mutex_unlock(&q_mutex);
            pthread_cond_broadcast(&full);
            break;
        }
    }
    pthread_exit(0);
}

double GetTimeInSeconds( timeval tvBegin, timeval tvEnd )
{
	long sec, usec;
	sec = tvEnd.tv_sec - tvBegin.tv_sec;
	usec = tvEnd.tv_usec - tvBegin.tv_usec;
	return (sec + 1e-6*usec);
}

int main(int argc, char *argv[]){
    string err = "Usage : ./HW1exec <producer #> <consumer #> <# of products> <queue size> <algorithm> <quantum> <seed> \nAll values must be positive";

    //initialize mutexes
    pthread_mutex_init(&q_mutex, nullptr);

    //initialize conditions
    pthread_cond_init(&cond_empty, nullptr);
    pthread_cond_init(&full, nullptr);

    //set global variable to arguments
    size_t queue_size;
    int producer_arg;
    int consumer_arg;
    int schedule_type;

    //ensure usage is correct
    if (argc != 8){
        cout<< err<< "\n";
        return 1;
    }

    if(!(stringstream(argv[7]) >> seed)){
        cout<< err<< "\n";
        return 1;
    }

    if(!(stringstream(argv[6]) >> quantum)){
        cout<< err<< "\n";
        return 1;
    }

    if(!(stringstream(argv[5]) >> schedule_type)){
        cout<< err<< "\n";
        return 1;
    }

    if(!(stringstream(argv[4]) >> queue_size)){
        cout<< err<< "\n";
        return 1;
    }

    if(!(stringstream(argv[3]) >> product_num)){
        cout<< err<< "\n";
        return 1;
    }

    if(!(stringstream(argv[2]) >> consumer_arg)){
        cout<< err<< "\n";
        return 1;
    }

    if(!(stringstream(argv[1]) >> producer_arg)){
        cout<< err<< "\n";
        return 1;
    }

    if(producer_arg <= 0 || consumer_arg <= 0 || product_num < 0 || queue_size < 0 || quantum <= 0 || seed == 0){
        cout<< err<< "\n";
        return 1;
    }

    //build make queue
    q = new Queue(queue_size);

    srand(seed);
    int producer_ids[producer_arg];             //producer ids
    int consumer_ids[consumer_arg];             //consumer ids
    pthread_t producer_threads[producer_arg];   //producer threads
    pthread_t consumer_threads[consumer_arg];   //consumer threads

    //get timestamp of start
    gettimeofday(&tv, nullptr);
    uint64_t s_time = tv.tv_sec*(uint64_t)1000000 + tv.tv_usec;

    //generate the producer and consumer threads
    for (int i = 0; i<producer_arg; i++){
        producer_ids[i] = i;
        pthread_create(&producer_threads[i], nullptr, producer, &producer_ids[i]);
    }

    //determine algorithm to use
    void *(*choice) (void*) = (!schedule_type) ? &consumer_FCFS : &consumer_RR;

    for (int i = 0; i<consumer_arg; i++){
        consumer_ids[i] = i;
        pthread_create(&consumer_threads[i], nullptr, choice, &consumer_ids[i]);
    }

    for (int i = 0; i<producer_arg; i++){
        pthread_join(producer_threads[i], nullptr);
    }

    //join producer and consumer threads
    for (int i = 0; i < consumer_arg; i++){
        pthread_join(consumer_threads[i], nullptr);
    }

    pthread_mutex_destroy(&q_mutex);
    pthread_cond_destroy(&full);
    pthread_cond_destroy(&cond_empty);

    //get timestamp of end
    gettimeofday(&tv, nullptr);
    uint64_t e_time = tv.tv_sec*(uint64_t)1000000 + tv.tv_usec; 

    //calculate the processing time for all products
    e_time = e_time - s_time;
    //print out total processing time
    cout<< "Total time for processing all products : "<< (e_time) << "\n";
    av_t = av_t/product_num;
    av_w = av_w/product_num;
    cout<< "Average turn-around time : "<< (av_t) << "\n";
    cout<< "Min turn-around time : "<< (min_t) << "\n";
    cout<< "Max turn-around time : "<< (max_t) << "\n";
    cout<< "Average wait time : "<< (av_w) << "\n";
    cout<< "Min wait time : "<< (min_w) << "\n";
    cout<< "Max wait time : "<< (max_w) << "\n";
    cout << "Producer throughput : " << (1 / (GetTimeInSeconds(producer_start, producer_end) / product_num)) * 60 << " products produced per minute" << endl;
    cout << "Consumer throughput : " << (1 / (GetTimeInSeconds(consumer_start, consumer_end) / product_num)) * 60 << " products consumed per minute" << endl;

    delete q;
    return 0;
}